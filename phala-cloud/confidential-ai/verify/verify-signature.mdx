---
description: Learn how to verify the integrity of your Confidential AI API requests.
title: Integrity Proof
---

## Why integrity proof matters

Every Confidential AI response comes with a cryptographic signature. This signature proves the AI output came from verified TEE hardware and nobody tampered with it along the way.

The signature cryptographically binds the request and response to the TEE's signing key. Any modification to the AI's response or injected fake data will break the signature verification. Without this check, you're trusting the transport layer. With it, you have end-to-end cryptographic proof from the TEE itself.

## Get the signature

After you make an AI request, you'll get a `chat_id` in the response. Use it to fetch the cryptographic signature:

```python
import requests

# After getting AI response with chat_id
chat_id = ai_response["id"]
model = "phala/deepseek-chat-v3-0324"  # or your model

# Fetch the signature
sig_response = requests.get(
    f"https://api.redpill.ai/v1/signature/{chat_id}?model={model}",
    headers={"Authorization": f"Bearer {api_key}"}
)
signature_data = sig_response.json()
```

The response gives you everything needed for verification. The `text` field contains hashes of your request and the AI's response, separated by a colon. The `signature` is the cryptographic proof from the TEE. The `signing_address` matches what you verified in the attestation report.

## Verify request and response hashes

Confirm the hashes in the `text` field match your actual request and response. `text` field format is `request_hash:response_hash`. 

```python
def calculate_request_hash(request_text: str):
    """Calculate SHA256 hash of request body"""
    return sha256(request_text.encode("utf-8")).hexdigest()

def calculate_response_hash(response_text: str):
    """Calculate SHA256 hash of response body"""
    return sha256(response_text.encode("utf-8")).hexdigest()
```

Check that your request and response hashes match the ones in the `text` field. This ensures the data wasn't swapped after signing.

## Verify signature

Now verify that the signature actually came from the TEE. You're checking that the `signing_address` from the signature matches what you verified in the attestation report, and that the signature is valid:

```python
from eth_account.messages import encode_defunct
from eth_account import Account

# The signing address from attestation report
expected_address = report["signing_address"]

# Verify the signature
message = encode_defunct(text=signature_data["text"])
recovered_address = Account.recover_message(message, signature=signature_data["signature"])

assert recovered_address.lower() == expected_address.lower()
```

When this check passes, you know the response came from the verified TEE. For complete verification, you should also confirm that your actual request and response content match the hashes in the signed message - this ensures the data wasn't swapped after signing.

## Verify using Etherscan (optional)

Want to double-check visually? Use [Etherscan's signature tool](https://etherscan.io/verifiedSignatures). Enter the `signing_address` from your attestation report, paste the `text` field from the signature response, and add the `signature` value. Click verify and Etherscan will confirm everything matches.

This gives you an independent third-party verification that the signature is valid.

## Complete example

For a full implementation that verifies both attestation and signatures, see the [signature verifier example](https://github.com/Phala-Network/confidential-ai-verifier/blob/f606cf8675b6d920cdec49f46c5624cbcd7f2f16/examples/signature_verifier.py).

## What's next

You've now verified both the TEE environment (attestation) and individual AI responses (signatures). Your Confidential AI setup is fully verified and trustworthy.
