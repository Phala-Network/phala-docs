---
title: Network Security Model
description: How network traffic is secured and isolated in Phala Cloud
---

Every network connection in Phala Cloud is encrypted at least twice. Here's how the network security works and what it means for your application architecture.

## Traffic Encryption Layers

Your network traffic goes through multiple encryption layers, each protecting against different threats.

### The Encryption Stack

When a client calls `https://abc123-8080.us.phala.network/api`, the request travels through:

```
Client → [TLS 1.3] → Gateway → [WireGuard] → CVM → [Plain HTTP] → Your Container
```

The gateway terminates TLS and re-encrypts with WireGuard before forwarding to your CVM. This double encryption means even if someone compromises the gateway, they still can't decrypt the WireGuard tunnel to your application.

Inside the CVM, traffic between your containers is unencrypted by default. If you need encryption there too, implement it in your application layer.

### TLS Passthrough Mode

Sometimes you need TLS all the way to your application. Add the `s` suffix to your URL:

```
Client → [TLS] → Gateway → [WireGuard + TLS] → CVM → [TLS] → Your Container
```

The gateway sees encrypted bytes and forwards them without decryption. Your container handles the TLS termination. Use this for:

- PostgreSQL/MySQL with `sslmode=require`
- Services that verify client certificates
- Custom protocols that manage their own TLS

Example connection string:
```bash
psql "host=abc123-5432s.us.phala.network port=443 sslmode=require"
```

## Network Isolation

Each CVM gets its own isolated network segment. Here's what that means practically.

### CVM Network Boundaries

Your CVM has:
- A unique WireGuard tunnel with its own keypair
- An isolated IP in the 10.0.0.0/8 range
- No route to other CVMs or the host

You can't ping another CVM. You can't connect to the host's localhost. You can't even discover what other CVMs exist on the same server.

### Container Networking Inside CVM

Within your CVM, containers communicate normally via Docker's bridge network:

```yaml
services:
  frontend:
    # Can reach backend at http://backend:3000
  backend:
    # Can reach postgres at postgres://db:5432
  db:
    # All internal, no encryption needed
```

This internal traffic never leaves the CVM's memory space, which is already hardware-encrypted.

### Outbound Connections

Your containers can make outbound connections freely:

```javascript
// This works normally
await fetch('https://api.openai.com/v1/completions');

// So does this
const redis = new Redis({
  host: 'redis.example.com',
  port: 6379,
  tls: {} // Your choice to use TLS
});
```

The host can see that a connection was made but can't see the content (it's in the WireGuard tunnel).

## How SNI Routing Works

The gateway uses Server Name Indication (SNI) to route traffic without decrypting it.

### Standard Mode Routing

For `abc123-8080.us.phala.network`:

1. Client sends TLS ClientHello with SNI
2. Gateway extracts `abc123-8080` from SNI
3. Looks up which CVM has app-id `abc123`
4. Forwards to that CVM's WireGuard tunnel on port 8080

The gateway can see which app and port you're accessing but not the request content.

### Passthrough Mode Routing

For `abc123-5432s.us.phala.network`:

1. Gateway sees the `s` suffix in SNI
2. Establishes TCP tunnel without TLS termination
3. Your container receives the raw TLS stream

The gateway can't see anything except encrypted bytes.

## Load Balancing and Health Checks

Understanding how the gateway distributes traffic helps you design resilient services.

### Health-Based Routing

The gateway tracks WireGuard handshake times:
- Last handshake < 5 minutes ago = healthy
- No recent handshake = unhealthy

Unhealthy instances stop receiving traffic automatically. No need for explicit health endpoints, though you can add them for container-level health.

### Session Affinity

Currently there's no sticky sessions. Requests distribute across healthy instances randomly. Design implications:

```javascript
// DON'T: Store session in memory
req.session.userId = 'user123';

// DO: Use external storage
await redis.set(`session:${sessionId}`, userData);
```

For WebSocket connections, the TCP connection stays with one instance for its lifetime. But reconnections might hit a different instance.

## Security Boundaries

Understanding what's protected and what isn't helps you make architectural decisions.

### What the Network Security Provides

**Protection from eavesdropping**: Multiple encryption layers prevent packet sniffing.

**Gateway compromise resilience**: Even if the gateway is compromised, WireGuard tunnel remains secure.

**CVM isolation**: Network segmentation prevents lateral movement between CVMs.

**Traffic analysis resistance**: WireGuard hides packet sizes and timing patterns.

### What You Still Need to Handle

**Application-layer auth**: Network security doesn't replace authentication.

```javascript
// Still needed
if (!req.headers.authorization) {
  return res.status(401).send('Unauthorized');
}
```

**Rate limiting**: Network layer doesn't prevent abuse.

```javascript
// Still recommended
app.use(rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100
}));
```

**Input validation**: Network encryption doesn't prevent injection attacks.

```javascript
// Still critical
const sanitized = validator.escape(userInput);
```

## Common Patterns and Solutions

### Database Connections

For managed databases requiring TLS:

```javascript
// Use passthrough mode
const db = new Pool({
  host: 'abc123-5432s.us.phala.network',
  port: 443,
  ssl: {
    rejectUnauthorized: true,
    ca: fs.readFileSync('server-ca.pem')
  }
});
```

### Microservice Communication

For service-to-service within the same CVM:

```javascript
// Use internal DNS names, no TLS needed
const userService = 'http://users:3000';
const authService = 'http://auth:4000';
```

For cross-CVM communication:

```javascript
// Use public URLs with TLS
const otherService = 'https://abc456-9000.us.phala.network';
```

### WebSocket Connections

WebSockets work over the standard HTTPS endpoint:

```javascript
// Client side
const ws = new WebSocket('wss://abc123-8080.us.phala.network/ws');

// Server side - no special config needed
wss.on('connection', (ws) => {
  // Connection already secured by gateway TLS
});
```

## Debugging Network Issues

### Checking Connectivity

From inside your container:

```bash
# Test outbound
curl -I https://example.com

# Check internal DNS
nslookup other-service

# View network interfaces
ip addr show

# Check routing table
ip route
```

### TLS Debugging

For passthrough mode issues:

```bash
# Test TLS handshake
openssl s_client -connect abc123-5432s.us.phala.network:443

# Check certificate
openssl s_client -connect abc123-5432s.us.phala.network:443 | openssl x509 -text
```

### Traffic Analysis

You can't capture WireGuard traffic (it's encrypted), but you can see container traffic:

```bash
# Inside container (install tcpdump first)
tcpdump -i eth0 -n port 80

# Connection count
netstat -an | grep ESTABLISHED | wc -l
```

Remember: the host can't run these commands inside your CVM. Only you can debug your own traffic.