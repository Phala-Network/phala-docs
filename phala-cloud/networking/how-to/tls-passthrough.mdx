---
title: Configure TLS Passthrough
description: Set up end-to-end encryption with TLS passthrough for databases and custom protocols
---

TLS passthrough forwards encrypted traffic directly to your service, enabling end-to-end encryption and advanced TLS features like client certificates.

## When to Use TLS Passthrough

**Use passthrough when you need:**
- End-to-end encryption (gateway cannot decrypt traffic)
- Client certificate authentication (mTLS)
- Custom TLS configurations
- Database connections with specific TLS requirements

**Use TLS termination when you need:**
- Simple HTTP/HTTPS services
- Automatic certificate management
- Load balancing with health checks
- Maximum compatibility with clients

## How TLS Passthrough Works

1. Client connects with TLS to `<app-id>-<port>s.us.phala.network:443`
2. Gateway forwards the encrypted TLS stream directly to your service
3. Your service handles the TLS handshake and decryption
4. All traffic remains encrypted between client and your application

The `s` suffix in the URL tells the gateway to use passthrough mode.

## PostgreSQL with TLS Passthrough

### Step 1: Configure PostgreSQL with TLS

```yaml
services:
  postgres:
    image: postgres:15
    ports:
      - "5432:5432"
    environment:
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_DB: myapp
      POSTGRES_USER: dbuser
    volumes:
      - postgres-data:/var/lib/postgresql/data
      - ./certs:/var/lib/postgresql/certs
    command: >
      postgres
      -c ssl=on
      -c ssl_cert_file=/var/lib/postgresql/certs/server.crt
      -c ssl_key_file=/var/lib/postgresql/certs/server.key

volumes:
  postgres-data:
```

### Step 2: Generate TLS Certificates

Create certificates for your PostgreSQL server:

```bash
# Generate private key
openssl genrsa -out server.key 2048

# Generate certificate signing request
openssl req -new -key server.key -out server.csr \
  -subj "/CN=<app-id>-5432s.us.phala.network"

# Generate self-signed certificate
openssl x509 -req -in server.csr -signkey server.key \
  -out server.crt -days 365

# Set proper permissions
chmod 600 server.key
chmod 644 server.crt

# Place in certs/ directory for volume mount
```

### Step 3: Connect with TLS Passthrough

```bash
# Connect using psql
psql "host=<app-id>-5432s.us.phala.network port=443 \
      dbname=myapp user=dbuser sslmode=require"
```

```python
# Python with psycopg2
import psycopg2

conn = psycopg2.connect(
    host="<app-id>-5432s.us.phala.network",
    port=443,
    database="myapp",
    user="dbuser",
    password=password,
    sslmode="require"
)
```

## MySQL with TLS Passthrough

```yaml
services:
  mysql:
    image: mysql:8.0
    ports:
      - "3306:3306"
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: myapp
    volumes:
      - mysql-data:/var/lib/mysql
      - ./certs:/etc/mysql/certs
    command: >
      --ssl-ca=/etc/mysql/certs/ca.pem
      --ssl-cert=/etc/mysql/certs/server.crt
      --ssl-key=/etc/mysql/certs/server.key
      --require_secure_transport=ON

volumes:
  mysql-data:
```

Connect to MySQL:
```bash
mysql -h <app-id>-3306s.us.phala.network -P 443 \
  -u root -p --ssl-mode=REQUIRED
```

## Client Certificate Authentication (mTLS)

TLS passthrough enables mutual TLS authentication where both client and server verify each other's certificates.

### Step 1: Generate CA and Client Certificates

```bash
# Create Certificate Authority
openssl genrsa -out ca.key 4096
openssl req -new -x509 -days 365 -key ca.key -out ca.crt \
  -subj "/CN=My CA"

# Create client certificate
openssl genrsa -out client.key 2048
openssl req -new -key client.key -out client.csr \
  -subj "/CN=client"
openssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key \
  -CAcreateserial -out client.crt -days 365
```

### Step 2: Configure Service for mTLS

```yaml
services:
  secure-service:
    image: nginx:alpine
    ports:
      - "8443:443"
    volumes:
      - ./nginx-mtls.conf:/etc/nginx/nginx.conf
      - ./certs:/etc/nginx/certs

# nginx-mtls.conf
events {}
http {
    server {
        listen 443 ssl;
        
        ssl_certificate /etc/nginx/certs/server.crt;
        ssl_certificate_key /etc/nginx/certs/server.key;
        ssl_client_certificate /etc/nginx/certs/ca.crt;
        ssl_verify_client on;
        
        location / {
            return 200 "Client cert: $ssl_client_s_dn\n";
            add_header Content-Type text/plain;
        }
    }
}
```

### Step 3: Connect with Client Certificate

```bash
# Using curl with client certificate
curl --cert client.crt --key client.key \
  --cacert ca.crt \
  https://<app-id>-8443s.us.phala.network:443
```

## Custom Protocol Example

For non-HTTP protocols that use TLS:

```yaml
services:
  custom-tls-service:
    image: your-custom-service:latest
    ports:
      - "9000:9000"
    environment:
      TLS_CERT_PATH: /certs/server.crt
      TLS_KEY_PATH: /certs/server.key
      TLS_ENABLED: "true"
    volumes:
      - ./certs:/certs
```

Clients connect to: `<app-id>-9000s.us.phala.network:443`

## Certificate Management

### Using Let's Encrypt Certificates

For production, use proper certificates:

```bash
# Get certificate using certbot
certbot certonly --dns-cloudflare \
  --dns-cloudflare-credentials ~/.secrets/cloudflare.ini \
  -d <app-id>-5432s.us.phala.network
```

### Certificate Renewal

Set up automatic renewal in your service:

```yaml
services:
  postgres:
    # ... postgres config
    volumes:
      - /etc/letsencrypt/live/<domain>:/var/lib/postgresql/certs:ro
    # Use cert renewal sidecar or init container
```

## Security Considerations

### Benefits of TLS Passthrough
- **True end-to-end encryption**: Gateway cannot decrypt traffic
- **Client certificate support**: Enable mTLS authentication
- **Custom TLS settings**: Full control over TLS configuration
- **Zero gateway trust**: Gateway cannot inspect or modify traffic

### Limitations
- **Certificate management**: You handle all certificate operations
- **No load balancer health checks**: Gateway cannot inspect traffic for health
- **Client compatibility**: Clients must support your TLS configuration
- **Debugging difficulty**: Encrypted traffic harder to troubleshoot

### Best Practices
- Use certificates with proper hostnames matching the gateway URL
- Implement proper certificate rotation
- Monitor certificate expiry dates
- Use strong cipher suites and TLS versions
- Consider certificate pinning for high-security applications

## Troubleshooting

**TLS handshake failures?**
- Verify certificate CN matches the gateway hostname
- Check certificate validity dates
- Ensure service is listening with TLS enabled

**Connection refused?**
- Confirm you're using the `s` suffix in the URL
- Verify service is configured for TLS
- Check port mapping in docker-compose.yml

**Certificate errors?**
- For self-signed certificates, configure client to accept them
- Verify certificate chain is complete
- Check certificate permissions in container

## Next Steps

- [Learn about network security](/phala-cloud/networking/security)
- [Set up custom domains](/phala-cloud/networking/how-to/setup-custom-domain)
- [Understand gateway components](/phala-cloud/networking/reference/components)